// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: containarium/v1/network.proto

package containariumv1

import (
	_ "github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2/options"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ACLAction represents the action to take when a rule matches
type ACLAction int32

const (
	// Unspecified action (should not be used)
	ACLAction_ACL_ACTION_UNSPECIFIED ACLAction = 0
	// Allow the traffic
	ACLAction_ACL_ACTION_ALLOW ACLAction = 1
	// Drop the traffic silently
	ACLAction_ACL_ACTION_DROP ACLAction = 2
	// Reject the traffic with ICMP response
	ACLAction_ACL_ACTION_REJECT ACLAction = 3
)

// Enum value maps for ACLAction.
var (
	ACLAction_name = map[int32]string{
		0: "ACL_ACTION_UNSPECIFIED",
		1: "ACL_ACTION_ALLOW",
		2: "ACL_ACTION_DROP",
		3: "ACL_ACTION_REJECT",
	}
	ACLAction_value = map[string]int32{
		"ACL_ACTION_UNSPECIFIED": 0,
		"ACL_ACTION_ALLOW":       1,
		"ACL_ACTION_DROP":        2,
		"ACL_ACTION_REJECT":      3,
	}
)

func (x ACLAction) Enum() *ACLAction {
	p := new(ACLAction)
	*p = x
	return p
}

func (x ACLAction) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ACLAction) Descriptor() protoreflect.EnumDescriptor {
	return file_containarium_v1_network_proto_enumTypes[0].Descriptor()
}

func (ACLAction) Type() protoreflect.EnumType {
	return &file_containarium_v1_network_proto_enumTypes[0]
}

func (x ACLAction) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ACLAction.Descriptor instead.
func (ACLAction) EnumDescriptor() ([]byte, []int) {
	return file_containarium_v1_network_proto_rawDescGZIP(), []int{0}
}

// ACLPreset represents predefined firewall rule sets
type ACLPreset int32

const (
	// Unspecified preset
	ACLPreset_ACL_PRESET_UNSPECIFIED ACLPreset = 0
	// Full isolation: only allow HTTP from proxy, block inter-container traffic
	ACLPreset_ACL_PRESET_FULL_ISOLATION ACLPreset = 1
	// HTTP only: allow HTTP/HTTPS inbound, standard egress
	ACLPreset_ACL_PRESET_HTTP_ONLY ACLPreset = 2
	// Permissive: allow all traffic (for development)
	ACLPreset_ACL_PRESET_PERMISSIVE ACLPreset = 3
	// Custom: user-defined rules
	ACLPreset_ACL_PRESET_CUSTOM ACLPreset = 4
)

// Enum value maps for ACLPreset.
var (
	ACLPreset_name = map[int32]string{
		0: "ACL_PRESET_UNSPECIFIED",
		1: "ACL_PRESET_FULL_ISOLATION",
		2: "ACL_PRESET_HTTP_ONLY",
		3: "ACL_PRESET_PERMISSIVE",
		4: "ACL_PRESET_CUSTOM",
	}
	ACLPreset_value = map[string]int32{
		"ACL_PRESET_UNSPECIFIED":    0,
		"ACL_PRESET_FULL_ISOLATION": 1,
		"ACL_PRESET_HTTP_ONLY":      2,
		"ACL_PRESET_PERMISSIVE":     3,
		"ACL_PRESET_CUSTOM":         4,
	}
)

func (x ACLPreset) Enum() *ACLPreset {
	p := new(ACLPreset)
	*p = x
	return p
}

func (x ACLPreset) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ACLPreset) Descriptor() protoreflect.EnumDescriptor {
	return file_containarium_v1_network_proto_enumTypes[1].Descriptor()
}

func (ACLPreset) Type() protoreflect.EnumType {
	return &file_containarium_v1_network_proto_enumTypes[1]
}

func (x ACLPreset) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ACLPreset.Descriptor instead.
func (ACLPreset) EnumDescriptor() ([]byte, []int) {
	return file_containarium_v1_network_proto_rawDescGZIP(), []int{1}
}

// ACLRule represents a single firewall rule
type ACLRule struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Rule priority (lower number = higher priority)
	Priority int32 `protobuf:"varint,1,opt,name=priority,proto3" json:"priority,omitempty"`
	// Action to take when rule matches
	Action ACLAction `protobuf:"varint,2,opt,name=action,proto3,enum=containarium.v1.ACLAction" json:"action,omitempty"`
	// Source address (CIDR notation, "@internal", "@external", or "*")
	Source string `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
	// Destination address (CIDR notation, "@internal", "@external", or "*")
	Destination string `protobuf:"bytes,4,opt,name=destination,proto3" json:"destination,omitempty"`
	// Destination port(s): "80", "80,443", "1000-2000", or "*"
	DestinationPort string `protobuf:"bytes,5,opt,name=destination_port,json=destinationPort,proto3" json:"destination_port,omitempty"`
	// Protocol: "tcp", "udp", "icmp", or "*"
	Protocol string `protobuf:"bytes,6,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Human-readable description
	Description   string `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ACLRule) Reset() {
	*x = ACLRule{}
	mi := &file_containarium_v1_network_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ACLRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ACLRule) ProtoMessage() {}

func (x *ACLRule) ProtoReflect() protoreflect.Message {
	mi := &file_containarium_v1_network_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ACLRule.ProtoReflect.Descriptor instead.
func (*ACLRule) Descriptor() ([]byte, []int) {
	return file_containarium_v1_network_proto_rawDescGZIP(), []int{0}
}

func (x *ACLRule) GetPriority() int32 {
	if x != nil {
		return x.Priority
	}
	return 0
}

func (x *ACLRule) GetAction() ACLAction {
	if x != nil {
		return x.Action
	}
	return ACLAction_ACL_ACTION_UNSPECIFIED
}

func (x *ACLRule) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *ACLRule) GetDestination() string {
	if x != nil {
		return x.Destination
	}
	return ""
}

func (x *ACLRule) GetDestinationPort() string {
	if x != nil {
		return x.DestinationPort
	}
	return ""
}

func (x *ACLRule) GetProtocol() string {
	if x != nil {
		return x.Protocol
	}
	return ""
}

func (x *ACLRule) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

// NetworkACL represents firewall rules for a container/app
type NetworkACL struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique ACL ID
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// ACL name (e.g., "acl-alice-web")
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Description
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Preset type (if using a predefined rule set)
	Preset ACLPreset `protobuf:"varint,4,opt,name=preset,proto3,enum=containarium.v1.ACLPreset" json:"preset,omitempty"`
	// Ingress (inbound) rules
	IngressRules []*ACLRule `protobuf:"bytes,5,rep,name=ingress_rules,json=ingressRules,proto3" json:"ingress_rules,omitempty"`
	// Egress (outbound) rules
	EgressRules []*ACLRule `protobuf:"bytes,6,rep,name=egress_rules,json=egressRules,proto3" json:"egress_rules,omitempty"`
	// Associated app ID (if app-specific)
	AppId string `protobuf:"bytes,7,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
	// Associated container name
	ContainerName string `protobuf:"bytes,8,opt,name=container_name,json=containerName,proto3" json:"container_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkACL) Reset() {
	*x = NetworkACL{}
	mi := &file_containarium_v1_network_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkACL) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkACL) ProtoMessage() {}

func (x *NetworkACL) ProtoReflect() protoreflect.Message {
	mi := &file_containarium_v1_network_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkACL.ProtoReflect.Descriptor instead.
func (*NetworkACL) Descriptor() ([]byte, []int) {
	return file_containarium_v1_network_proto_rawDescGZIP(), []int{1}
}

func (x *NetworkACL) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *NetworkACL) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *NetworkACL) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *NetworkACL) GetPreset() ACLPreset {
	if x != nil {
		return x.Preset
	}
	return ACLPreset_ACL_PRESET_UNSPECIFIED
}

func (x *NetworkACL) GetIngressRules() []*ACLRule {
	if x != nil {
		return x.IngressRules
	}
	return nil
}

func (x *NetworkACL) GetEgressRules() []*ACLRule {
	if x != nil {
		return x.EgressRules
	}
	return nil
}

func (x *NetworkACL) GetAppId() string {
	if x != nil {
		return x.AppId
	}
	return ""
}

func (x *NetworkACL) GetContainerName() string {
	if x != nil {
		return x.ContainerName
	}
	return ""
}

// ProxyRoute represents a DNS/domain to container mapping
type ProxyRoute struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Subdomain (e.g., "alice-web")
	Subdomain string `protobuf:"bytes,1,opt,name=subdomain,proto3" json:"subdomain,omitempty"`
	// Full domain (e.g., "alice-web.containarium.dev")
	FullDomain string `protobuf:"bytes,2,opt,name=full_domain,json=fullDomain,proto3" json:"full_domain,omitempty"`
	// Container IP address
	ContainerIp string `protobuf:"bytes,3,opt,name=container_ip,json=containerIp,proto3" json:"container_ip,omitempty"`
	// Container port
	Port int32 `protobuf:"varint,4,opt,name=port,proto3" json:"port,omitempty"`
	// Whether the route is active
	Active bool `protobuf:"varint,5,opt,name=active,proto3" json:"active,omitempty"`
	// Associated app ID
	AppId string `protobuf:"bytes,6,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
	// Associated app name
	AppName string `protobuf:"bytes,7,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	// Owner username
	Username      string `protobuf:"bytes,8,opt,name=username,proto3" json:"username,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProxyRoute) Reset() {
	*x = ProxyRoute{}
	mi := &file_containarium_v1_network_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProxyRoute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProxyRoute) ProtoMessage() {}

func (x *ProxyRoute) ProtoReflect() protoreflect.Message {
	mi := &file_containarium_v1_network_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProxyRoute.ProtoReflect.Descriptor instead.
func (*ProxyRoute) Descriptor() ([]byte, []int) {
	return file_containarium_v1_network_proto_rawDescGZIP(), []int{2}
}

func (x *ProxyRoute) GetSubdomain() string {
	if x != nil {
		return x.Subdomain
	}
	return ""
}

func (x *ProxyRoute) GetFullDomain() string {
	if x != nil {
		return x.FullDomain
	}
	return ""
}

func (x *ProxyRoute) GetContainerIp() string {
	if x != nil {
		return x.ContainerIp
	}
	return ""
}

func (x *ProxyRoute) GetPort() int32 {
	if x != nil {
		return x.Port
	}
	return 0
}

func (x *ProxyRoute) GetActive() bool {
	if x != nil {
		return x.Active
	}
	return false
}

func (x *ProxyRoute) GetAppId() string {
	if x != nil {
		return x.AppId
	}
	return ""
}

func (x *ProxyRoute) GetAppName() string {
	if x != nil {
		return x.AppName
	}
	return ""
}

func (x *ProxyRoute) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

// NetworkNode represents a node in the network topology
type NetworkNode struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Node ID
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Node type: "proxy", "container", "app"
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// Display name
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// IP address (if applicable)
	IpAddress string `protobuf:"bytes,4,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	// Node state: "running", "stopped", "error"
	State string `protobuf:"bytes,5,opt,name=state,proto3" json:"state,omitempty"`
	// Associated ACL name
	AclName       string `protobuf:"bytes,6,opt,name=acl_name,json=aclName,proto3" json:"acl_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkNode) Reset() {
	*x = NetworkNode{}
	mi := &file_containarium_v1_network_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkNode) ProtoMessage() {}

func (x *NetworkNode) ProtoReflect() protoreflect.Message {
	mi := &file_containarium_v1_network_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkNode.ProtoReflect.Descriptor instead.
func (*NetworkNode) Descriptor() ([]byte, []int) {
	return file_containarium_v1_network_proto_rawDescGZIP(), []int{3}
}

func (x *NetworkNode) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *NetworkNode) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *NetworkNode) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *NetworkNode) GetIpAddress() string {
	if x != nil {
		return x.IpAddress
	}
	return ""
}

func (x *NetworkNode) GetState() string {
	if x != nil {
		return x.State
	}
	return ""
}

func (x *NetworkNode) GetAclName() string {
	if x != nil {
		return x.AclName
	}
	return ""
}

// NetworkEdge represents a connection between nodes
type NetworkEdge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Source node ID
	Source string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	// Target node ID
	Target string `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	// Edge type: "route", "blocked", "allowed"
	Type string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	// Port(s) on this edge
	Ports string `protobuf:"bytes,4,opt,name=ports,proto3" json:"ports,omitempty"`
	// Protocol
	Protocol      string `protobuf:"bytes,5,opt,name=protocol,proto3" json:"protocol,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkEdge) Reset() {
	*x = NetworkEdge{}
	mi := &file_containarium_v1_network_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkEdge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkEdge) ProtoMessage() {}

func (x *NetworkEdge) ProtoReflect() protoreflect.Message {
	mi := &file_containarium_v1_network_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkEdge.ProtoReflect.Descriptor instead.
func (*NetworkEdge) Descriptor() ([]byte, []int) {
	return file_containarium_v1_network_proto_rawDescGZIP(), []int{4}
}

func (x *NetworkEdge) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *NetworkEdge) GetTarget() string {
	if x != nil {
		return x.Target
	}
	return ""
}

func (x *NetworkEdge) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *NetworkEdge) GetPorts() string {
	if x != nil {
		return x.Ports
	}
	return ""
}

func (x *NetworkEdge) GetProtocol() string {
	if x != nil {
		return x.Protocol
	}
	return ""
}

// NetworkTopology represents the complete network visualization
type NetworkTopology struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// All nodes in the network
	Nodes []*NetworkNode `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// All edges (connections) between nodes
	Edges []*NetworkEdge `protobuf:"bytes,2,rep,name=edges,proto3" json:"edges,omitempty"`
	// Network CIDR (e.g., "10.100.0.0/24")
	NetworkCidr string `protobuf:"bytes,3,opt,name=network_cidr,json=networkCidr,proto3" json:"network_cidr,omitempty"`
	// Gateway IP
	GatewayIp     string `protobuf:"bytes,4,opt,name=gateway_ip,json=gatewayIp,proto3" json:"gateway_ip,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkTopology) Reset() {
	*x = NetworkTopology{}
	mi := &file_containarium_v1_network_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkTopology) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkTopology) ProtoMessage() {}

func (x *NetworkTopology) ProtoReflect() protoreflect.Message {
	mi := &file_containarium_v1_network_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkTopology.ProtoReflect.Descriptor instead.
func (*NetworkTopology) Descriptor() ([]byte, []int) {
	return file_containarium_v1_network_proto_rawDescGZIP(), []int{5}
}

func (x *NetworkTopology) GetNodes() []*NetworkNode {
	if x != nil {
		return x.Nodes
	}
	return nil
}

func (x *NetworkTopology) GetEdges() []*NetworkEdge {
	if x != nil {
		return x.Edges
	}
	return nil
}

func (x *NetworkTopology) GetNetworkCidr() string {
	if x != nil {
		return x.NetworkCidr
	}
	return ""
}

func (x *NetworkTopology) GetGatewayIp() string {
	if x != nil {
		return x.GatewayIp
	}
	return ""
}

// GetRoutesRequest lists all proxy routes
type GetRoutesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Filter by username (optional)
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	// Filter by active status (optional)
	ActiveOnly    bool `protobuf:"varint,2,opt,name=active_only,json=activeOnly,proto3" json:"active_only,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRoutesRequest) Reset() {
	*x = GetRoutesRequest{}
	mi := &file_containarium_v1_network_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRoutesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRoutesRequest) ProtoMessage() {}

func (x *GetRoutesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_containarium_v1_network_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRoutesRequest.ProtoReflect.Descriptor instead.
func (*GetRoutesRequest) Descriptor() ([]byte, []int) {
	return file_containarium_v1_network_proto_rawDescGZIP(), []int{6}
}

func (x *GetRoutesRequest) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *GetRoutesRequest) GetActiveOnly() bool {
	if x != nil {
		return x.ActiveOnly
	}
	return false
}

type GetRoutesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of routes
	Routes []*ProxyRoute `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
	// Total count
	TotalCount    int32 `protobuf:"varint,2,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRoutesResponse) Reset() {
	*x = GetRoutesResponse{}
	mi := &file_containarium_v1_network_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRoutesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRoutesResponse) ProtoMessage() {}

func (x *GetRoutesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_containarium_v1_network_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRoutesResponse.ProtoReflect.Descriptor instead.
func (*GetRoutesResponse) Descriptor() ([]byte, []int) {
	return file_containarium_v1_network_proto_rawDescGZIP(), []int{7}
}

func (x *GetRoutesResponse) GetRoutes() []*ProxyRoute {
	if x != nil {
		return x.Routes
	}
	return nil
}

func (x *GetRoutesResponse) GetTotalCount() int32 {
	if x != nil {
		return x.TotalCount
	}
	return 0
}

// GetContainerACLRequest gets firewall rules for a DevBox container
type GetContainerACLRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Username (container owner)
	Username      string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetContainerACLRequest) Reset() {
	*x = GetContainerACLRequest{}
	mi := &file_containarium_v1_network_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetContainerACLRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetContainerACLRequest) ProtoMessage() {}

func (x *GetContainerACLRequest) ProtoReflect() protoreflect.Message {
	mi := &file_containarium_v1_network_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetContainerACLRequest.ProtoReflect.Descriptor instead.
func (*GetContainerACLRequest) Descriptor() ([]byte, []int) {
	return file_containarium_v1_network_proto_rawDescGZIP(), []int{8}
}

func (x *GetContainerACLRequest) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

type GetContainerACLResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Firewall rules
	Acl           *NetworkACL `protobuf:"bytes,1,opt,name=acl,proto3" json:"acl,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetContainerACLResponse) Reset() {
	*x = GetContainerACLResponse{}
	mi := &file_containarium_v1_network_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetContainerACLResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetContainerACLResponse) ProtoMessage() {}

func (x *GetContainerACLResponse) ProtoReflect() protoreflect.Message {
	mi := &file_containarium_v1_network_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetContainerACLResponse.ProtoReflect.Descriptor instead.
func (*GetContainerACLResponse) Descriptor() ([]byte, []int) {
	return file_containarium_v1_network_proto_rawDescGZIP(), []int{9}
}

func (x *GetContainerACLResponse) GetAcl() *NetworkACL {
	if x != nil {
		return x.Acl
	}
	return nil
}

// UpdateContainerACLRequest updates firewall rules for a DevBox container
type UpdateContainerACLRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Username (container owner)
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	// Use a preset (mutually exclusive with custom rules)
	Preset ACLPreset `protobuf:"varint,2,opt,name=preset,proto3,enum=containarium.v1.ACLPreset" json:"preset,omitempty"`
	// Custom ingress rules (only if preset is CUSTOM)
	IngressRules []*ACLRule `protobuf:"bytes,3,rep,name=ingress_rules,json=ingressRules,proto3" json:"ingress_rules,omitempty"`
	// Custom egress rules (only if preset is CUSTOM)
	EgressRules   []*ACLRule `protobuf:"bytes,4,rep,name=egress_rules,json=egressRules,proto3" json:"egress_rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateContainerACLRequest) Reset() {
	*x = UpdateContainerACLRequest{}
	mi := &file_containarium_v1_network_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateContainerACLRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateContainerACLRequest) ProtoMessage() {}

func (x *UpdateContainerACLRequest) ProtoReflect() protoreflect.Message {
	mi := &file_containarium_v1_network_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateContainerACLRequest.ProtoReflect.Descriptor instead.
func (*UpdateContainerACLRequest) Descriptor() ([]byte, []int) {
	return file_containarium_v1_network_proto_rawDescGZIP(), []int{10}
}

func (x *UpdateContainerACLRequest) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *UpdateContainerACLRequest) GetPreset() ACLPreset {
	if x != nil {
		return x.Preset
	}
	return ACLPreset_ACL_PRESET_UNSPECIFIED
}

func (x *UpdateContainerACLRequest) GetIngressRules() []*ACLRule {
	if x != nil {
		return x.IngressRules
	}
	return nil
}

func (x *UpdateContainerACLRequest) GetEgressRules() []*ACLRule {
	if x != nil {
		return x.EgressRules
	}
	return nil
}

type UpdateContainerACLResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Updated ACL
	Acl *NetworkACL `protobuf:"bytes,1,opt,name=acl,proto3" json:"acl,omitempty"`
	// Status message
	Message       string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateContainerACLResponse) Reset() {
	*x = UpdateContainerACLResponse{}
	mi := &file_containarium_v1_network_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateContainerACLResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateContainerACLResponse) ProtoMessage() {}

func (x *UpdateContainerACLResponse) ProtoReflect() protoreflect.Message {
	mi := &file_containarium_v1_network_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateContainerACLResponse.ProtoReflect.Descriptor instead.
func (*UpdateContainerACLResponse) Descriptor() ([]byte, []int) {
	return file_containarium_v1_network_proto_rawDescGZIP(), []int{11}
}

func (x *UpdateContainerACLResponse) GetAcl() *NetworkACL {
	if x != nil {
		return x.Acl
	}
	return nil
}

func (x *UpdateContainerACLResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// GetNetworkTopologyRequest gets network visualization data
type GetNetworkTopologyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Include stopped containers/apps
	IncludeStopped bool `protobuf:"varint,1,opt,name=include_stopped,json=includeStopped,proto3" json:"include_stopped,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *GetNetworkTopologyRequest) Reset() {
	*x = GetNetworkTopologyRequest{}
	mi := &file_containarium_v1_network_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetNetworkTopologyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetNetworkTopologyRequest) ProtoMessage() {}

func (x *GetNetworkTopologyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_containarium_v1_network_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetNetworkTopologyRequest.ProtoReflect.Descriptor instead.
func (*GetNetworkTopologyRequest) Descriptor() ([]byte, []int) {
	return file_containarium_v1_network_proto_rawDescGZIP(), []int{12}
}

func (x *GetNetworkTopologyRequest) GetIncludeStopped() bool {
	if x != nil {
		return x.IncludeStopped
	}
	return false
}

type GetNetworkTopologyResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Network topology data
	Topology      *NetworkTopology `protobuf:"bytes,1,opt,name=topology,proto3" json:"topology,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetNetworkTopologyResponse) Reset() {
	*x = GetNetworkTopologyResponse{}
	mi := &file_containarium_v1_network_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetNetworkTopologyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetNetworkTopologyResponse) ProtoMessage() {}

func (x *GetNetworkTopologyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_containarium_v1_network_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetNetworkTopologyResponse.ProtoReflect.Descriptor instead.
func (*GetNetworkTopologyResponse) Descriptor() ([]byte, []int) {
	return file_containarium_v1_network_proto_rawDescGZIP(), []int{13}
}

func (x *GetNetworkTopologyResponse) GetTopology() *NetworkTopology {
	if x != nil {
		return x.Topology
	}
	return nil
}

// ListACLPresetsRequest lists available ACL presets
type ListACLPresetsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListACLPresetsRequest) Reset() {
	*x = ListACLPresetsRequest{}
	mi := &file_containarium_v1_network_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListACLPresetsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListACLPresetsRequest) ProtoMessage() {}

func (x *ListACLPresetsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_containarium_v1_network_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListACLPresetsRequest.ProtoReflect.Descriptor instead.
func (*ListACLPresetsRequest) Descriptor() ([]byte, []int) {
	return file_containarium_v1_network_proto_rawDescGZIP(), []int{14}
}

type ACLPresetInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Preset type
	Preset ACLPreset `protobuf:"varint,1,opt,name=preset,proto3,enum=containarium.v1.ACLPreset" json:"preset,omitempty"`
	// Display name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Description
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Default ingress rules for this preset
	DefaultIngressRules []*ACLRule `protobuf:"bytes,4,rep,name=default_ingress_rules,json=defaultIngressRules,proto3" json:"default_ingress_rules,omitempty"`
	// Default egress rules for this preset
	DefaultEgressRules []*ACLRule `protobuf:"bytes,5,rep,name=default_egress_rules,json=defaultEgressRules,proto3" json:"default_egress_rules,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *ACLPresetInfo) Reset() {
	*x = ACLPresetInfo{}
	mi := &file_containarium_v1_network_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ACLPresetInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ACLPresetInfo) ProtoMessage() {}

func (x *ACLPresetInfo) ProtoReflect() protoreflect.Message {
	mi := &file_containarium_v1_network_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ACLPresetInfo.ProtoReflect.Descriptor instead.
func (*ACLPresetInfo) Descriptor() ([]byte, []int) {
	return file_containarium_v1_network_proto_rawDescGZIP(), []int{15}
}

func (x *ACLPresetInfo) GetPreset() ACLPreset {
	if x != nil {
		return x.Preset
	}
	return ACLPreset_ACL_PRESET_UNSPECIFIED
}

func (x *ACLPresetInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ACLPresetInfo) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *ACLPresetInfo) GetDefaultIngressRules() []*ACLRule {
	if x != nil {
		return x.DefaultIngressRules
	}
	return nil
}

func (x *ACLPresetInfo) GetDefaultEgressRules() []*ACLRule {
	if x != nil {
		return x.DefaultEgressRules
	}
	return nil
}

type ListACLPresetsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Available presets
	Presets       []*ACLPresetInfo `protobuf:"bytes,1,rep,name=presets,proto3" json:"presets,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListACLPresetsResponse) Reset() {
	*x = ListACLPresetsResponse{}
	mi := &file_containarium_v1_network_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListACLPresetsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListACLPresetsResponse) ProtoMessage() {}

func (x *ListACLPresetsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_containarium_v1_network_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListACLPresetsResponse.ProtoReflect.Descriptor instead.
func (*ListACLPresetsResponse) Descriptor() ([]byte, []int) {
	return file_containarium_v1_network_proto_rawDescGZIP(), []int{16}
}

func (x *ListACLPresetsResponse) GetPresets() []*ACLPresetInfo {
	if x != nil {
		return x.Presets
	}
	return nil
}

var File_containarium_v1_network_proto protoreflect.FileDescriptor

const file_containarium_v1_network_proto_rawDesc = "" +
	"\n" +
	"\x1dcontainarium/v1/network.proto\x12\x0fcontainarium.v1\x1a\x1cgoogle/api/annotations.proto\x1a.protoc-gen-openapiv2/options/annotations.proto\"\xfc\x01\n" +
	"\aACLRule\x12\x1a\n" +
	"\bpriority\x18\x01 \x01(\x05R\bpriority\x122\n" +
	"\x06action\x18\x02 \x01(\x0e2\x1a.containarium.v1.ACLActionR\x06action\x12\x16\n" +
	"\x06source\x18\x03 \x01(\tR\x06source\x12 \n" +
	"\vdestination\x18\x04 \x01(\tR\vdestination\x12)\n" +
	"\x10destination_port\x18\x05 \x01(\tR\x0fdestinationPort\x12\x1a\n" +
	"\bprotocol\x18\x06 \x01(\tR\bprotocol\x12 \n" +
	"\vdescription\x18\a \x01(\tR\vdescription\"\xc0\x02\n" +
	"\n" +
	"NetworkACL\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x122\n" +
	"\x06preset\x18\x04 \x01(\x0e2\x1a.containarium.v1.ACLPresetR\x06preset\x12=\n" +
	"\ringress_rules\x18\x05 \x03(\v2\x18.containarium.v1.ACLRuleR\fingressRules\x12;\n" +
	"\fegress_rules\x18\x06 \x03(\v2\x18.containarium.v1.ACLRuleR\vegressRules\x12\x15\n" +
	"\x06app_id\x18\a \x01(\tR\x05appId\x12%\n" +
	"\x0econtainer_name\x18\b \x01(\tR\rcontainerName\"\xe8\x01\n" +
	"\n" +
	"ProxyRoute\x12\x1c\n" +
	"\tsubdomain\x18\x01 \x01(\tR\tsubdomain\x12\x1f\n" +
	"\vfull_domain\x18\x02 \x01(\tR\n" +
	"fullDomain\x12!\n" +
	"\fcontainer_ip\x18\x03 \x01(\tR\vcontainerIp\x12\x12\n" +
	"\x04port\x18\x04 \x01(\x05R\x04port\x12\x16\n" +
	"\x06active\x18\x05 \x01(\bR\x06active\x12\x15\n" +
	"\x06app_id\x18\x06 \x01(\tR\x05appId\x12\x19\n" +
	"\bapp_name\x18\a \x01(\tR\aappName\x12\x1a\n" +
	"\busername\x18\b \x01(\tR\busername\"\x95\x01\n" +
	"\vNetworkNode\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04type\x18\x02 \x01(\tR\x04type\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12\x1d\n" +
	"\n" +
	"ip_address\x18\x04 \x01(\tR\tipAddress\x12\x14\n" +
	"\x05state\x18\x05 \x01(\tR\x05state\x12\x19\n" +
	"\bacl_name\x18\x06 \x01(\tR\aaclName\"\x83\x01\n" +
	"\vNetworkEdge\x12\x16\n" +
	"\x06source\x18\x01 \x01(\tR\x06source\x12\x16\n" +
	"\x06target\x18\x02 \x01(\tR\x06target\x12\x12\n" +
	"\x04type\x18\x03 \x01(\tR\x04type\x12\x14\n" +
	"\x05ports\x18\x04 \x01(\tR\x05ports\x12\x1a\n" +
	"\bprotocol\x18\x05 \x01(\tR\bprotocol\"\xbb\x01\n" +
	"\x0fNetworkTopology\x122\n" +
	"\x05nodes\x18\x01 \x03(\v2\x1c.containarium.v1.NetworkNodeR\x05nodes\x122\n" +
	"\x05edges\x18\x02 \x03(\v2\x1c.containarium.v1.NetworkEdgeR\x05edges\x12!\n" +
	"\fnetwork_cidr\x18\x03 \x01(\tR\vnetworkCidr\x12\x1d\n" +
	"\n" +
	"gateway_ip\x18\x04 \x01(\tR\tgatewayIp\"O\n" +
	"\x10GetRoutesRequest\x12\x1a\n" +
	"\busername\x18\x01 \x01(\tR\busername\x12\x1f\n" +
	"\vactive_only\x18\x02 \x01(\bR\n" +
	"activeOnly\"i\n" +
	"\x11GetRoutesResponse\x123\n" +
	"\x06routes\x18\x01 \x03(\v2\x1b.containarium.v1.ProxyRouteR\x06routes\x12\x1f\n" +
	"\vtotal_count\x18\x02 \x01(\x05R\n" +
	"totalCount\"4\n" +
	"\x16GetContainerACLRequest\x12\x1a\n" +
	"\busername\x18\x01 \x01(\tR\busername\"H\n" +
	"\x17GetContainerACLResponse\x12-\n" +
	"\x03acl\x18\x01 \x01(\v2\x1b.containarium.v1.NetworkACLR\x03acl\"\xe7\x01\n" +
	"\x19UpdateContainerACLRequest\x12\x1a\n" +
	"\busername\x18\x01 \x01(\tR\busername\x122\n" +
	"\x06preset\x18\x02 \x01(\x0e2\x1a.containarium.v1.ACLPresetR\x06preset\x12=\n" +
	"\ringress_rules\x18\x03 \x03(\v2\x18.containarium.v1.ACLRuleR\fingressRules\x12;\n" +
	"\fegress_rules\x18\x04 \x03(\v2\x18.containarium.v1.ACLRuleR\vegressRules\"e\n" +
	"\x1aUpdateContainerACLResponse\x12-\n" +
	"\x03acl\x18\x01 \x01(\v2\x1b.containarium.v1.NetworkACLR\x03acl\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\"D\n" +
	"\x19GetNetworkTopologyRequest\x12'\n" +
	"\x0finclude_stopped\x18\x01 \x01(\bR\x0eincludeStopped\"Z\n" +
	"\x1aGetNetworkTopologyResponse\x12<\n" +
	"\btopology\x18\x01 \x01(\v2 .containarium.v1.NetworkTopologyR\btopology\"\x17\n" +
	"\x15ListACLPresetsRequest\"\x93\x02\n" +
	"\rACLPresetInfo\x122\n" +
	"\x06preset\x18\x01 \x01(\x0e2\x1a.containarium.v1.ACLPresetR\x06preset\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12L\n" +
	"\x15default_ingress_rules\x18\x04 \x03(\v2\x18.containarium.v1.ACLRuleR\x13defaultIngressRules\x12J\n" +
	"\x14default_egress_rules\x18\x05 \x03(\v2\x18.containarium.v1.ACLRuleR\x12defaultEgressRules\"R\n" +
	"\x16ListACLPresetsResponse\x128\n" +
	"\apresets\x18\x01 \x03(\v2\x1e.containarium.v1.ACLPresetInfoR\apresets*i\n" +
	"\tACLAction\x12\x1a\n" +
	"\x16ACL_ACTION_UNSPECIFIED\x10\x00\x12\x14\n" +
	"\x10ACL_ACTION_ALLOW\x10\x01\x12\x13\n" +
	"\x0fACL_ACTION_DROP\x10\x02\x12\x15\n" +
	"\x11ACL_ACTION_REJECT\x10\x03*\x92\x01\n" +
	"\tACLPreset\x12\x1a\n" +
	"\x16ACL_PRESET_UNSPECIFIED\x10\x00\x12\x1d\n" +
	"\x19ACL_PRESET_FULL_ISOLATION\x10\x01\x12\x18\n" +
	"\x14ACL_PRESET_HTTP_ONLY\x10\x02\x12\x19\n" +
	"\x15ACL_PRESET_PERMISSIVE\x10\x03\x12\x15\n" +
	"\x11ACL_PRESET_CUSTOM\x10\x042\xce\n" +
	"\n" +
	"\x0eNetworkService\x12\xdd\x01\n" +
	"\tGetRoutes\x12!.containarium.v1.GetRoutesRequest\x1a\".containarium.v1.GetRoutesResponse\"\x88\x01\x92Ak\n" +
	"\aNetwork\x12\x11List proxy routes\x1aMReturns all DNS/domain to container mappings configured in the reverse proxy.\x82\xd3\xe4\x93\x02\x14\x12\x12/v1/network/routes\x12\x8a\x02\n" +
	"\x0fGetContainerACL\x12'.containarium.v1.GetContainerACLRequest\x1a(.containarium.v1.GetContainerACLResponse\"\xa3\x01\x92A{\n" +
	"\aNetwork\x12\x1cGet container firewall rules\x1aRReturns the network ACL (firewall rules) configured for a user's DevBox container.\x82\xd3\xe4\x93\x02\x1f\x12\x1d/v1/containers/{username}/acl\x12\xb7\x02\n" +
	"\x12UpdateContainerACL\x12*.containarium.v1.UpdateContainerACLRequest\x1a+.containarium.v1.UpdateContainerACLResponse\"\xc7\x01\x92A\x9b\x01\n" +
	"\aNetwork\x12\x1fUpdate container firewall rules\x1aoUpdates the network ACL for a DevBox container. Use a preset for common configurations or specify custom rules.\x82\xd3\xe4\x93\x02\":\x01*\x1a\x1d/v1/containers/{username}/acl\x12\xa4\x02\n" +
	"\x12GetNetworkTopology\x12*.containarium.v1.GetNetworkTopologyRequest\x1a+.containarium.v1.GetNetworkTopologyResponse\"\xb4\x01\x92A\x94\x01\n" +
	"\aNetwork\x12\x14Get network topology\x1asReturns the network topology including all containers, apps, proxy routes, and their connections for visualization.\x82\xd3\xe4\x93\x02\x16\x12\x14/v1/network/topology\x12\xed\x01\n" +
	"\x0eListACLPresets\x12&.containarium.v1.ListACLPresetsRequest\x1a'.containarium.v1.ListACLPresetsResponse\"\x89\x01\x92Ag\n" +
	"\aNetwork\x12\x10List ACL presets\x1aJReturns available firewall rule presets with their default configurations.\x82\xd3\xe4\x93\x02\x19\x12\x17/v1/network/acl-presetsBKZIgithub.com/footprintai/containarium/pkg/pb/containarium/v1;containariumv1b\x06proto3"

var (
	file_containarium_v1_network_proto_rawDescOnce sync.Once
	file_containarium_v1_network_proto_rawDescData []byte
)

func file_containarium_v1_network_proto_rawDescGZIP() []byte {
	file_containarium_v1_network_proto_rawDescOnce.Do(func() {
		file_containarium_v1_network_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_containarium_v1_network_proto_rawDesc), len(file_containarium_v1_network_proto_rawDesc)))
	})
	return file_containarium_v1_network_proto_rawDescData
}

var file_containarium_v1_network_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_containarium_v1_network_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_containarium_v1_network_proto_goTypes = []any{
	(ACLAction)(0),                     // 0: containarium.v1.ACLAction
	(ACLPreset)(0),                     // 1: containarium.v1.ACLPreset
	(*ACLRule)(nil),                    // 2: containarium.v1.ACLRule
	(*NetworkACL)(nil),                 // 3: containarium.v1.NetworkACL
	(*ProxyRoute)(nil),                 // 4: containarium.v1.ProxyRoute
	(*NetworkNode)(nil),                // 5: containarium.v1.NetworkNode
	(*NetworkEdge)(nil),                // 6: containarium.v1.NetworkEdge
	(*NetworkTopology)(nil),            // 7: containarium.v1.NetworkTopology
	(*GetRoutesRequest)(nil),           // 8: containarium.v1.GetRoutesRequest
	(*GetRoutesResponse)(nil),          // 9: containarium.v1.GetRoutesResponse
	(*GetContainerACLRequest)(nil),     // 10: containarium.v1.GetContainerACLRequest
	(*GetContainerACLResponse)(nil),    // 11: containarium.v1.GetContainerACLResponse
	(*UpdateContainerACLRequest)(nil),  // 12: containarium.v1.UpdateContainerACLRequest
	(*UpdateContainerACLResponse)(nil), // 13: containarium.v1.UpdateContainerACLResponse
	(*GetNetworkTopologyRequest)(nil),  // 14: containarium.v1.GetNetworkTopologyRequest
	(*GetNetworkTopologyResponse)(nil), // 15: containarium.v1.GetNetworkTopologyResponse
	(*ListACLPresetsRequest)(nil),      // 16: containarium.v1.ListACLPresetsRequest
	(*ACLPresetInfo)(nil),              // 17: containarium.v1.ACLPresetInfo
	(*ListACLPresetsResponse)(nil),     // 18: containarium.v1.ListACLPresetsResponse
}
var file_containarium_v1_network_proto_depIdxs = []int32{
	0,  // 0: containarium.v1.ACLRule.action:type_name -> containarium.v1.ACLAction
	1,  // 1: containarium.v1.NetworkACL.preset:type_name -> containarium.v1.ACLPreset
	2,  // 2: containarium.v1.NetworkACL.ingress_rules:type_name -> containarium.v1.ACLRule
	2,  // 3: containarium.v1.NetworkACL.egress_rules:type_name -> containarium.v1.ACLRule
	5,  // 4: containarium.v1.NetworkTopology.nodes:type_name -> containarium.v1.NetworkNode
	6,  // 5: containarium.v1.NetworkTopology.edges:type_name -> containarium.v1.NetworkEdge
	4,  // 6: containarium.v1.GetRoutesResponse.routes:type_name -> containarium.v1.ProxyRoute
	3,  // 7: containarium.v1.GetContainerACLResponse.acl:type_name -> containarium.v1.NetworkACL
	1,  // 8: containarium.v1.UpdateContainerACLRequest.preset:type_name -> containarium.v1.ACLPreset
	2,  // 9: containarium.v1.UpdateContainerACLRequest.ingress_rules:type_name -> containarium.v1.ACLRule
	2,  // 10: containarium.v1.UpdateContainerACLRequest.egress_rules:type_name -> containarium.v1.ACLRule
	3,  // 11: containarium.v1.UpdateContainerACLResponse.acl:type_name -> containarium.v1.NetworkACL
	7,  // 12: containarium.v1.GetNetworkTopologyResponse.topology:type_name -> containarium.v1.NetworkTopology
	1,  // 13: containarium.v1.ACLPresetInfo.preset:type_name -> containarium.v1.ACLPreset
	2,  // 14: containarium.v1.ACLPresetInfo.default_ingress_rules:type_name -> containarium.v1.ACLRule
	2,  // 15: containarium.v1.ACLPresetInfo.default_egress_rules:type_name -> containarium.v1.ACLRule
	17, // 16: containarium.v1.ListACLPresetsResponse.presets:type_name -> containarium.v1.ACLPresetInfo
	8,  // 17: containarium.v1.NetworkService.GetRoutes:input_type -> containarium.v1.GetRoutesRequest
	10, // 18: containarium.v1.NetworkService.GetContainerACL:input_type -> containarium.v1.GetContainerACLRequest
	12, // 19: containarium.v1.NetworkService.UpdateContainerACL:input_type -> containarium.v1.UpdateContainerACLRequest
	14, // 20: containarium.v1.NetworkService.GetNetworkTopology:input_type -> containarium.v1.GetNetworkTopologyRequest
	16, // 21: containarium.v1.NetworkService.ListACLPresets:input_type -> containarium.v1.ListACLPresetsRequest
	9,  // 22: containarium.v1.NetworkService.GetRoutes:output_type -> containarium.v1.GetRoutesResponse
	11, // 23: containarium.v1.NetworkService.GetContainerACL:output_type -> containarium.v1.GetContainerACLResponse
	13, // 24: containarium.v1.NetworkService.UpdateContainerACL:output_type -> containarium.v1.UpdateContainerACLResponse
	15, // 25: containarium.v1.NetworkService.GetNetworkTopology:output_type -> containarium.v1.GetNetworkTopologyResponse
	18, // 26: containarium.v1.NetworkService.ListACLPresets:output_type -> containarium.v1.ListACLPresetsResponse
	22, // [22:27] is the sub-list for method output_type
	17, // [17:22] is the sub-list for method input_type
	17, // [17:17] is the sub-list for extension type_name
	17, // [17:17] is the sub-list for extension extendee
	0,  // [0:17] is the sub-list for field type_name
}

func init() { file_containarium_v1_network_proto_init() }
func file_containarium_v1_network_proto_init() {
	if File_containarium_v1_network_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_containarium_v1_network_proto_rawDesc), len(file_containarium_v1_network_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_containarium_v1_network_proto_goTypes,
		DependencyIndexes: file_containarium_v1_network_proto_depIdxs,
		EnumInfos:         file_containarium_v1_network_proto_enumTypes,
		MessageInfos:      file_containarium_v1_network_proto_msgTypes,
	}.Build()
	File_containarium_v1_network_proto = out.File
	file_containarium_v1_network_proto_goTypes = nil
	file_containarium_v1_network_proto_depIdxs = nil
}
